---
title: 安全岗笔试题集
date: 2021-02-28 15:31:00
tags:
---
# 导语
持续更新0.0

# 深信服
## Q1：请尽可能列举你知道的网站未能正确使用图片验证码机制的情况，以及如何绕过其限制？
- 图形验证码的内容可OCR识别
- 多阶段的过程，先校验验证码，成功之后的下一步不需要验证码，可以直接抓包，跳过第一步的验证
- 验证码在服务段校验后，没有立即失效，需要客户端再次请求才会更新，只要客户端不再请求验证码即可使用原来的验证码
- 生成验证码的模块是否根据提供的参数生成验证码，如果是说明存在漏洞
- 有些验证码与数据包中的某个参数绑定，比如cookie中的某个属性，只要它们相匹配，验证码就认为是有效的。这种机制存在漏洞。
- 在某些情况下，验证码隐藏在HTML源码或通过其他方式获得“明文”
- 在服务器端，是否只有在验证码检验通过后才进行用户名和密码的检验，如果不是说明存在漏洞。

## Q2：请尽可能列举你知道的网站未能安全实现文件上传功能的情况，以及如何绕过其限制？
允许直接上传脚本文件：php、jsp、aspx
结合web server解析漏洞
一、IIS 5.x/6.0解析漏洞
IIS 6.0解析利用方法有两种
1.目录解析 /xx.asp/xx.jpg
2.文件解析 wooyun.asp;.jpg
二、IIS 7.0/IIS 7.5/ Nginx <8.03畸形解析漏洞
在默认Fast-CGI开启状况下,黑阔上传一个名字为wooyun.jpg，内容为
<?PHP                                                      ?>');?>的文件
然后访问wooyun.jpg/.php,在这个目录下就会生成一句话木马 shell.php
三、Nginx <8.03 空字节代码执行漏洞
影响版:0.5.,0.6., 0.7 <= 0.7.65, 0.8 <= 0.8.37
Nginx在图片中嵌入PHP代码
然后通过访问xxx.jpg%00.php来执行其中的代码
四、Apache解析漏洞
Apache 是从右到左开始判断解析,如果为不可识别解析,就再往左判断.
比如wooyun.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php.
五、其他
在windows环境下，xx.jpg[空格] 或xx.jpg. 这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点,黑客可以通过抓包，在文件名后加一个空格或者点绕过黑名单.若上传成功，空格和点都会被windows自动消除,这样也可以getshell。
如果在Apache中.htaccess可被执行.且可被上传.那可以尝试在.htaccess中写入:
<FilesMatch "wooyun.jpg"> SetHandler application/x-httpd-php </FilesMatch>
然后再上传shell.jpg的木马, 这样shell.jpg就可解析为php文件。
前端文件名限制
firebug禁用javascript
firebug修改允许上传类型
Burp绕过限制
本地构造html代码
后端检测-MIME
修改MIME类型
后端检测-文件头
我们可以通过使用jpg图片马来绕过！
后端检测-文件扩展名，黑名单与白名单
大小写
寻找黑白名单的遗漏点
配合解析漏洞来绕过
%00和\x00截断
文件内容绕过:
图片马
加密webshell
填充垃圾数据

## Q3：利用汇编语言编写一道程序，不使用乘法以及除法指令，计算(((AX\*5)+300h)/2-100h)\*8的值。
```
mov bx,ax
shl ax,2
add ax,bx
add ax,300h
shr ax,1
sub ax,100h
shl ax,3
```

## Q4:阅读如下代码，其中main函数参数可以被攻击者控制，那么main函数中存在哪些漏洞，指出漏洞具体位置及问题，并说明这些代码中漏洞的修复方法
``` C
//读取指定的文件中的内容并返回该文件base64编码后的内容，函数失败则返回NULL，在非NULL情况下需要调用该函数后手动释放内存，该函数中不存在安全性问题

char *readBase64File(char *fileName);

int main(int argc, char* argv[])
{
    char filePath[260];
    char fileCmd[512];
    char *fileName;
    int dirIdx;
    char *fileContent;
    char *dirPaths[4];
    dirPaths[0] = ”/home/data1/”;
    dirPaths[1] = ”/home/data2/”;
    dirPaths[2] = ”/home/data3/”;
    dirPaths[3] = ”/home/data4/”;
    fileName = argv[1];
    dirIdx = atoi(argv[2]);
    if (dirIdx > 3)
    {
        printf(“file index error!\n”);
        return -1;
    }
    strcpy(filePath, dirPaths[dirIdx]);
    if (strlen(filePath) + strlen(fileName) < 260)
        strcat(filePath, fileName);
    else
        return -1;
    fileContent = readBase64File(filePath);
    if (fileContent == NULL)
    {
        printf(“read filecontent error!\n”);
    }
    else
    {
        printf(“file content is: %s\n”, fileContent);
        free(fileContents);
    }
    strcpy(fileCmd, “rm ”);
    strcat(fileCmd, fileName);
    printf(fileCmd);
    system(fileCmd);
    return 0;
}
```
命令执行，目录穿越，缓冲区溢出，数组越界访问，格式化字符串
（1）system(fileCmd);处存在命令执行漏洞及任意文件删除问题，需要进行命令执行过滤
（2）printf(fileCmd);处存在格式化字符串漏洞，此处可以通过%s来打印命令
（3）fileContent =readBase64File(filePath);处存在目录穿越，任意文件读取漏洞，此处可以对../这种目录穿越特征进行过滤
（4）strcpy(filePath, dirPaths[dirIdx]);处存在数组访问越界，从而可以也可以导致缓冲区溢出问题，判断有符号数的dirIdx时需要判断其大于等于0

## Q5:谈谈在WEB类安全问题的应急处置过程中web日志溯源攻击路径的思路？
在对WEB日志进行安全分析时，可以按照下面两种思路展开，逐步深入，还原整个攻击过程。
首先确定受到攻击的时间范围，以此为线索，查找这个时间范围内可疑的日志，根据可疑ip、攻击特征等进一步排查（WEB日志会记录客户端对WEB应用的访问请求，这其中包括正常用户的访问请求和攻击者的恶意行为。通过大量的分析，我们发现攻击者在对网站入侵时，向网站发起的请求中会带有特定的攻击特征，如利用WEB扫描器在对网站进行漏洞扫描时往往会产生大量的404错误日志，当有攻击者对网站进行SQL注入漏洞探测时，WEB访问日志中通常会出现and 1=1等字样），最终锁定攻击者，确认攻击的手段，还原攻击过程。

## Q6:心脏滴血漏洞产生的原因，危害都有哪些？
Heartbleed漏洞，这项严重缺陷(CVE-2014-0160)的产生是由于未能在memcpy()调用受害用户输入内容作为长度参数之前正确进行边界检查。攻击者可以追踪OpenSSL所分配的64KB缓存、将超出必要范围的字节信息复制到缓存当中再返回缓存内容，这样一来受害者的内存内容就会以每次64KB的速度进行泄露。通过读取网络服务器内存，攻击者可以访问敏感数据，从而危及服务器及用户的安全。敏感的安全数据，如服务器的专用主密钥，可使攻击者在服务器和客户端未使用完全正向保密时，通过被动中间人攻击解密当前的或已存储的传输数据，或在通信方使用完全正向保密的情况下，发动主动中间人攻击。攻击者无法控制服务器返回的数据，因为服务器会响应随机的内存块。
漏洞还可能暴露其他用户的敏感请求和响应，包括用户任何形式的POST请求数据，会话cookie和密码，这能使攻击者可以劫持其他用户的服务身份。在其披露时，约有17%或五十万通过认证机构认证的互联网安全网络服务器被认为容易受到攻击。电子前哨基金会，ArsTechnica，和布鲁斯·施奈尔都认为心脏出血漏洞是“灾难性的”。
漏洞让特定版本的openSSL成为无需钥匙即可开启的“废锁”，入侵者每次可以翻检户主的64K信息，只要有足够的耐心和时间，就可以翻检足够多的数据，拼凑出户主的银行密码、私信等敏感数据。

## Q7:Apache，IIS，Nginx的文件解析漏洞都是如何解析和利用的？
Apache解析漏洞。它 是从右到左开始判断解析,如果为不可识别解析,就再往左判断.
比如upupimage.php.owf.rar “.owf”和”.rar”?这两种后缀是apache不可识别解析,apache就会把upupimage.php.owf.rar解析成php.
IIS 解析漏洞。
一是IIS5.x/6.0中的/xx.asp/xx.jpg ，网站下建立文件夹的名字为.asp、.asa 的文件夹，其目录内的任何扩展名的文件都被IIS当作asp文件来解析并执行。
二 是123.asp;.jpg会被服务器看成是123.asp，IIS6.0 默认的可执行文件除了asp还包含这三种/upupimage.asa/upupimage.cer /upupimage.cdx 
nginx解析漏洞。
一是nginx默认Fast-CGI开启状况下,黑阔上传一个名字为upupimage.jpg，然后访问upupimage.jpg/.php。
二是Nginx在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码，影响版:0.5.,0.6.,0.7 <= 0.7.65, 0.8 <= 0.8.37

## Q8：从哪些方面可以进行CSRF漏洞防御？
CSRF漏洞防御主要可以从三个层面进行，即服务端的防御、用户端的防御和安全设备的防御。
1.检测HTTPreferer字段同域。根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。比如某银行的转账是通过用户访问http://bank.test/test?page=10&userID=101&money=10000 页面完成，用户必须先登录bank.test，然后通过点击页面上的按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是转账按钮所在页面的URL（本例中，通常是以bank. test域名开头的地址）。而如果攻击者要对银行网站实施CSRF攻击，他只能在自己的网站构造请求，当用户通过攻击者的网站发送请求到银行时，该请求的Referer是指向攻击者的网站。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，如果是以bank. test开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，就有可能是CSRF攻击，则拒绝该请求
2.限制sessioncookie的生命周期。CSRF攻击是有条件的，当用户访问恶意链接时，认证的cookie仍然有效，所以当用户关闭页面时要及时清除认证cookie
3.使用验证码。虽然攻击者已经通过获取cookie得到用户的身份，但是通过在你的表单中包括验证码，事实上网站已经消除了跨站请求伪造攻击的风险。可以在任何需要执行操作的任何表单中使用这个流程。
4.cookie关键字段设置HttpOnly属性。可以在一定程度防御CSRF。

## Q9：登录一个应用程序后，服务器建立以下cookie:
```
Set-cookie: sess=abcd1129efgh;
```
单击“退出”按钮后，应用程序执行以下客户端脚本：
```
document.cookie=”sess=”;
document.location=”/”
```
通过这种行为，可以得出什么结论？

退出功能存在缺陷。
上述脚本使浏览器中当前保存的会话令牌失效，也就是说，随后的任何请求将不会提交之前的令牌值。然后，该脚本将启动一个指向应用程序起始页面的重定向。任何访问受保护功能的尝试将遭到拒绝，因为相关请求并不属于通过验证的会话的一部分。
客户端应用程序并未将已执行了退出操作这一信息传达给服务器。服务器上的用户会话将仍处于活动状态，如果将之前发布的令牌提交给服务器，服务器将继续接受该令牌。在会话超时或以其他方式被清除之前，这种情况会一直持续。在这段时间内，已通过某种方式截获或猜测出令牌值的攻击者就可以继续使用令牌来劫持用户会话。
简答说就是只把客户端cookie清了而没有去管服务端。

## Q10：简述一下SOCKS协议TCP穿透原理
客户端（需要代理方）向SOCKS服务器（代理方）发出代理请求信息
SOCKS代理服务器应答
客户端接到应答后向SOCKS服务器发送目的IP和端口
SOCKS服务器与目的IP、端口建立TCP连接，并向客户端应答可以代理
SOCKS服务器将客户端发出的信息传到目的方，将目的方发出的信息传到客户端，代理完成

## Q11：简述一下利用SQL注入漏洞拖取数据的过程
收集应用程序的可测试点
确定可测试点是否是可注入点
数据库类型探测
数据库基本信息探测，包括当前数据库用户名、当前用户名权限、数据库表信息（几个表、几个列、表名称、列名称）
利用漏洞爆取数据（明注入、盲注入）

## Q12：用C语言分别编写含有以下漏洞的函数：
（1）通过函数的输入参数可控的缓冲区溢出漏洞的函数，以及对应的修复该漏洞的函数
（2）通过函数的输入参数可控的整数溢出漏洞的函数，以及对应的修复该漏洞的函数
样例：
含有格式化字符串漏洞函数：
``` C
void format_vul(char *outstr){
    printf(outstr);
}
```
格式化字符串漏洞的修复函数：
``` C
void format_vul(char *outstr){
    printf("%s", outstr);
}
```

``` C
缓冲区溢出漏洞函数：
void buffer_vul(char *buf){
    char str[20];
    strcpy(str, buf);
}
缓冲区溢出漏洞修复：
void buffer_vul(char *buf){
    char str[20];
    if (strlen(buf) >= 20)
        return;
    strcpy(str, buf);
}

整数溢出漏洞函数：
void int_vul(int idx, int type){
    int arr[8];
    if (idx >= 8)
        return;
    arr[idx] = type;
}
整数溢出漏洞修复：
void int_vul(int idx, int type){
    int arr[8];
    if (idx >= 8 || idx < 0)
        return;
    arr[idx] = type;
}
```

## Q13：汇编反写C
```
func:
        mov     ecx, eax
        lea     edx, [ecx+1]
loop:
        mov     al, [ecx]
        inc     ecx
        test    al, al
        jnz     loop
        sub     ecx, edx
        mov     eax, ecx
        ret


reverse:
        mov     ebp, eax ;eax为输入的参数1
        mov     edi, edx ;edx为输入的参数2
        mov     esi, ebx ;ebx为输入的参数3

        mov     eax, ebp
        call    func
        push    eax

        xor     ebx, ebx
        xor     ecx, ecx
        xor     ebp, ebp
        jmp     label4

label1:
        lea     eax, [ebp*4]
        add     eax, edi
        mov     eax, [eax]
        cmp     eax, ecx
        jbe     label2

        mov     ebx, ecx
        mov     ecx, eax
        jmp     label3

label2:
        cmp     eax, ebx
        jbe     label3

        mov     ebx, eax

label3:
        inc     ebp

label4:
        cmp     ebp, esi
        jb      label1
        pop     eax
        add     eax, ebx
        add     eax, ecx
        ret
```
以上为汇编码的两个函数func和reverse，分析这两个函数并编写等价的C代码函数
等价的C代码函数如下：
``` C
int mystrLen(char *str)
{
    char *pstr = str+1;
    while( *str++ );
    return str - pstr;
}

int reverse(char *str, unsigned int numArr[], unsigned int numLen)
{
    int len;
    int i;
    unsigned int big1,big2;
    len = mystrLen(str);
    big1 = 0;
    big2 = 0;
    for (i = 0; i < numLen; i++)
    {
        if (numArr[i] > big1){
            big2 = big1;
            big1 = numArr[i];
        }
        else if (numArr[i] > big2){
            big2 = numArr[i];
        }
    }
    return len + big1 + big2;
}
```

## Q14:请回答如下端口默认对应的服务，以及在渗透测试过程中我们可以从哪些角度考虑其安全问题。
端口：21、22、873、1433、3306、6379、11211
<table border="0" cellspacing="2" class="MsoNormalTable ke-zeroborder" style="width: 478.4pt;margin-left: 3.15pt;">  <tbody>   <tr>    <td>     <p>      <span>端口</span>     </p>    </td>    <td>     <p>      <span>服务</span>     </p>    </td>    <td>     <p>      <span>说明</span>     </p>    </td>   </tr>   <tr>    <td>     <p>      <span>21</span>     </p>    </td>    <td>     <p>      <span>FTP</span>     </p>    </td>    <td>     <p>      <span>匿名访问\弱口令</span>     </p>    </td>   </tr>   <tr>    <td>     <p>      <span>22</span>     </p>    </td>    <td>     <p>      <span>SSH</span>     </p>    </td>    <td>     <p>      <span>弱口令</span>     </p>    </td>   </tr>   <tr>    <td>     <p>      <span>873</span>     </p>    </td>    <td>     <p>      <span>rsync</span>     </p>    </td>    <td>     <p>      <span>未授权访问\弱口令 </span>     </p>    </td>   </tr>   <tr>    <td>     <p>      <span>1433</span>     </p>    </td>    <td>     <p>      <span>mssql</span>     </p>    </td>    <td>     <p>      <span>弱口令</span>     </p>    </td>   </tr>   <tr>    <td>     <p>      <span>3306</span>     </p>    </td>    <td>     <p>      <span>mysql</span>     </p>    </td>    <td>     <p>      <span>弱口令</span>     </p>    </td>   </tr>   <tr>    <td>     <p>      <span>6379</span>     </p>    </td>    <td>     <p>      <span>redis</span>     </p>    </td>    <td>     <p>      <span>一般无验证，直接访问 </span>     </p>    </td>   </tr>   <tr>    <td>     <p>      <span>11211</span>     </p>    </td>    <td>     <p>      <span>memcache</span>     </p>    </td>    <td>     <p>      <span>内存泄露\未授权访问 </span>     </p>    </td>   </tr>  </tbody> </table>

## Q15：某系统存在防注入模块，注入时会被提示：
![](1.png)
如何利用这个防注入系统拿shell？

直接写入一句话木马，即将木马写入了存放非法注入行为的数据库中，这个时候可以尝试寻找网站的配置文件，直接连接。

## Q16:发现test.jsp?id=1234 注入点，你有哪几种思路获取 webshell，哪种是优选？
一是在数据库中查找管理员用户名密码，使用管理员账户去上传web shell。但是有可能密码md5加密不好查询。
二是直接通过sql的into outfile写web shell到目标文件系统。但是要求数据库有写文件权限。
第二种是优选

## Q17：CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？
XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。 
CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer 
XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。

## Q18：写出病毒木马常用的hook技术以及大致实现。
1.INLINE HOOK将需要hook的api函数入口的部分代码修改为跳转代码，如将函数的       序言代码push ebp;mov ebp,esp等代码修改为jmp hook_func的指令
2.IAT HOOK遍历可执行程序的导入表，并修改导入表的地址为要跳转的函数地址
3.消息hook机制 利用setwindowshook函数配合全局参数劫持windows下的消息传递，利用callnexthookex将消息进行下一步的分发。通常该技术用来进行dll注入。
4.SSDT hook在内核层上通过KeServiceDescriptorTable内核导出变量来获取对应的ssdt表地址，接着查询需要hook的内核api的索引，将ssdt表对应索引的函数地址改为需要跳转的函数地址。

## Q19：CSRF、SSRF和重放攻击有什么区别？
CSRF是跨站请求伪造攻击，由客户端发起 
SSRF是服务器端请求伪造，由服务器发起 
重放攻击是将截获的数据包进行重放，达到身份认证等目的

## Q20：mysql的网站注入，5.0以上和5.0以下有什么区别？
5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。
5.0以下是多用户单操作，5.0以上是多用户多操做。

## Q21:无论是在日常的网络维护，还是在渗透测试过程中，经常会使用到端口转发、代理、隧道技术，请详尽地说明这三种技术的异同点。
端口转发，顾名思义，就是指访问某一IP和端口的流量会被转发到另一个IP和端口，通过中转的方式，来访问无法直接访问到的主机和服务。
代理和隧道本质上都是一种端口转发技术，代理的特点是代理服务端可以根据客户端的数据包，自动判断向哪个目标机器转发；隧道技术主要是对端口转发的流量进行了加密和封装的处理。
如果可以说明本地端口转发、远程端口转发、动态端口转发、正向代理、反向代理的具体细节就更好了。
如果可以举出例子就更好了。

## Q22:将下列汇编代码逆成等价的C代码
```
func1:                
                push    ebp
                mov     ebp, esp
                sub     esp, 14h
                push    esi
                mov     eax, 4
                imul    ecx, eax, 0
                mov     edx, [ebp+0Ch]
                mov     eax, [edx+ecx]
                mov     [ebp-8], eax
                mov     ecx, 4
                shl     ecx, 0
                mov     edx, [ebp+0Ch]
                mov     eax, [edx+ecx]
                mov     [ebp-0Ch], eax
                mov     [ebp-14h], 61C88647h
                mov     [ebp-4], 0C6EF3720h
                mov     [ebp-10h], 0
                jmp     short loc_401369

loc_401360:                            
                mov     ecx, [ebp-10h]
                add     ecx, 1
                mov     [ebp-10h], ecx

loc_401369:                            
                mov     edx, [ebp-10h]
                cmp     edx, [ebp+8]
                jnb     short loc_4013D3
                mov     eax, [ebp-8]
                shl     eax, 5
                mov     ecx, [ebp-8]
                shr     ecx, 4
                xor     eax, ecx
                add     eax, [ebp-8]
                mov     edx, [ebp-4]
                shr     edx, 0Bh
                and     edx, 3
                mov     ecx, [ebp+10h]
                mov     esi, [ebp-4]
                add     esi, [ecx+edx*4]
                xor     eax, esi
                mov     edx, [ebp-0Ch]
                sub     edx, eax
                mov     [ebp-0Ch], edx
                mov     eax, [ebp-4]
                add     eax, [ebp-14h]
                mov     [ebp-4], eax
                mov     ecx, [ebp-0Ch]
                shl     ecx, 5
                mov     edx, [ebp-0Ch]
                shr     edx, 4
                xor     ecx, edx
                add     ecx, [ebp-0Ch]
                mov     eax, [ebp-4]
                and     eax, 3
                mov     edx, [ebp+10h]
                mov     esi, [ebp-4]
                add     esi, [edx+eax*4]
                xor     ecx, esi
                mov     eax, [ebp-8]
                sub     eax, ecx
                mov     [ebp-8], eax
                jmp     short loc_401360
 
loc_4013D3:                            
                mov     ecx, 4
                imul    edx, ecx, 0
                mov     eax, [ebp+0Ch]
                mov     ecx, [ebp-8]
                mov     [eax+edx], ecx
                mov     edx, 4
                shl     edx, 0
                mov     eax, [ebp+0Ch]
                mov     ecx, [ebp-0Ch]
                mov     [eax+edx], ecx
                pop     esi
                mov     esp, ebp
                pop     ebp
                retn
                endp

func1(1,2,3)
```

``` C
func1(int a,int b,int c)

{

int var1,var2,var3;
var1 = *b;
var2 = *(b+4);
var3 = 0xC6EF3720;

for (int i =0;i<a;i++)
{
var2 -=(*(DWORD*)(c+4*((var3>>11)&3))+var3)^(var1+((var1>>4)^(var1<<5)));
var3 +=0x61c88647;
var1-=(*(DWORD*)(c+4*(var3&3))+var3)^(var2+((var2>>4)^(var2<<5)));
}

*(DWORD*)b = var1;
*(DWORD*)(b+4) = var2;

return b;
}
```

# 奇安信
## Q1：以下工具或命令不能实现端口转发是（）
A. ssh
B. netsh
C. htran
D. msbuild

答案：D

解析：
ssh可以进行本地端口转发、远程端口转发和动态端口转发。
https://zhuanlan.zhihu.com/p/26547381
netsh：https://www.cnblogs.com/vivfeng/p/11605811.html
htran（这个还有好几个其他的端口转发工具）：https://cloud.tencent.com/developer/article/1365274
Msbuild是VS用来构建软件的平台，它采用XML格式的项目文件，这些文件定义了构建各种平台和配置的要求。.NET版本4中引入的MSBuild内联任务功能允许将C＃代码插入XML项目文件中。内联任务MSBuild将编译并执行内联任务。他存在的安全隐患是可以用来绕过applocker。具体可以看下面这些文章
https://blog.csdn.net/qq_38154820/article/details/106330230
https://zhuanlan.zhihu.com/p/27810834
我个人的理解是，Msbuild和make相类似，是编译整个项目的工具，Msbuild接受的xml就相当于make用的makefile，他也像make一样调用编译器去编译，它调用的编译工具是C#编译器csc罢了。但是Msbuild接受的xml里可以有C#，且Msbuild会把C#编译执行了，这也就导致他可以绕过appblocker。

## Q2：下列可用于PHP反序列化漏洞利用的伪协议是（）
A. php://file
B. php://phar
C. php://input
D. php://zlib

答案：B
https://paper.seebug.org/680/

## Q3：下列命令中不能用来反弹Shell是（）
A. bash
B. nc
C. icmpsh
D. cscript

答案：D
讲道理我觉得cscript也能反弹，只要你能写一个合理的脚本给他运行一下。搞不太懂。
https://www.cnblogs.com/xiaozi/p/13493010.html

## Q4：SSRF可被攻击者用来（）
A. 对本地端口进行扫描
B. 对内网web应用进行指纹识别
C. 利用file协议读取本地文件
D. 可用来进行钓鱼攻击

答案：ABC
ssrf可以实现的攻击主要有
1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;
2.攻击运行在内网或本地的应用程序（比如溢出）;
3.对内网web应用进行指纹识别，通过访问默认文件实现;
4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;
5.利用file协议读取本地文件等。

## Q5：下列哪些工具可以用于文件下载
A. Certutil
B. Bitadmin
C. Net.exe
D. Powershell

答案： ABD
https://www.jianshu.com/p/bdf67ffe0b21

## Q6：关于WannaCry勒索病毒说法正确的是（）
A. 利用MS17-010漏洞进行传播
B. 源于“方程式黑客组织”的工具被公开
C. 文件加密后会添加后缀 .WNCRYT
D. 关闭445、3389等端口可阻断传播

答案：ABC
D应该是关掉445和139

## Q7：以下哪几种工具可以对网站进行自动化Web漏洞扫描（）
A. AWVS
B. APPScan
C. Fiddler
D. Netsparker

答案：ABD

## Q8:SQL注入的时候读取MySQL安装路径的SQL查询语句是（）
A. select @@version
B. select @@datadir
C. select @@basedir
D. select database()

答案：C

## Q9:Oracle数据库默认服务端口是（）
A. 1433
B. 3306
C. 3389
D. 1521

答案：D

## Q10:下列微软数据库（SQL Server）系统存储过程中哪些可以被攻击者用来提权（）
A. xp_cmdshell
B. sp_oacreate
C. openrowset
D. sp_replcmds

答案：ABC
https://blog.51cto.com/11797152/2411770

## Q11:MySQL盲注可用的函数或方法有哪些（）
A. Sleep
B. Benchmark
C. 笛卡尔积
D. RLIKE

答案：ABCD

## Q12：用来识别通过代理访问Web服务器的客户端最原始的IP地址的HTTP字段是（）
A. X_FORWARDED_FOR
B. CLIENT_IP
C. REMOTE_ADDR
D. REFERER

答案：A

## Q13：以下命令可以用来获取DNS记录的是（）
A. ping
B. who
C. traceroute
D. dig

答案：D

## Q14：LDAP协议运行的端口是（）
A. 389
B. 110
C. 53
D. 161

答案：A

## Q15：在TCP/IP模型中，下列哪些是网络层中的协议（）
A. ICMP
B. SMTP
C. SNMP
D. ARP

答案：AD

## Q16:用于隐蔽信道攻击利用的常见协议有（）
A. HTTP
B. DNS
C. FTP
D. ICMP

答案：ABD
这我感觉C也可以呀，可能不常见吧。





参考：
https://blog.csdn.net/qq_38154820/article/details/106330230