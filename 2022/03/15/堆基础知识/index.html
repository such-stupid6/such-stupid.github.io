<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>堆基础知识 | π1L4r</title><meta name="keywords" content="pwn,basic"><meta name="author" content="π1L4r"><meta name="copyright" content="π1L4r"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="导语入门堆溢出之前，首先要对堆有个基础的了解 堆的简单介绍可能经常听到这个说法，栈内存由os操作，堆地址由程序员操作。这个说法有一定的可取之处。 堆管理器处于用户程序与内核中间，主要做以下工作  响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足">
<meta property="og:type" content="article">
<meta property="og:title" content="堆基础知识">
<meta property="og:url" content="https://blog.pillar.fun/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="π1L4r">
<meta property="og:description" content="导语入门堆溢出之前，首先要对堆有个基础的了解 堆的简单介绍可能经常听到这个说法，栈内存由os操作，堆地址由程序员操作。这个说法有一定的可取之处。 堆管理器处于用户程序与内核中间，主要做以下工作  响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.pillar.fun/img/cover3.jpg">
<meta property="article:published_time" content="2022-03-15T06:01:33.000Z">
<meta property="article:modified_time" content="2023-03-23T10:02:05.027Z">
<meta property="article:author" content="π1L4r">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="basic">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.pillar.fun/img/cover3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.pillar.fun/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?ebd90b1061e819b5a156373d237674c9";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"WKHA6YLSNH","apiKey":"46dba96b67832c36609d31c01e6772af","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-23 18:02:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macWhite.css"> <link rel="stylesheet" href="/css/background.css"> <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.6.0/build/styles/default.min.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="π1L4r" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/author.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">π1L4r</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">堆基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-15T06:01:33.000Z" title="发表于 2022-03-15 14:01:33">2022-03-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-23T10:02:05.027Z" title="更新于 2023-03-23 18:02:05">2023-03-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>入门堆溢出之前，首先要对堆有个基础的了解</p>
<h1 id="堆的简单介绍"><a href="#堆的简单介绍" class="headerlink" title="堆的简单介绍"></a>堆的简单介绍</h1><p>可能经常听到这个说法，栈内存由os操作，堆地址由程序员操作。这个说法有一定的可取之处。</p>
<p>堆管理器处于用户程序与内核中间，主要做以下工作</p>
<ol>
<li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li>
<li>管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li>
</ol>
<p>Linux 中早期的堆分配与回收由 Doug Lea 实现，但是多线程共享堆的内存空间，在申请的时候需要加锁，这就导致了多线程对堆的操作效率很低。在glibc-2.3.x只有，目前的堆由ptmalloc2管理。</p>
<p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想， <strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong> 。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<h1 id="程序的内存结构"><a href="#程序的内存结构" class="headerlink" title="程序的内存结构"></a>程序的内存结构</h1><p><img src="/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1678860579761.png" alt="1678860579761"></p>
<p>一段代码的内存都有bss段、text段和data段</p>
<p>text段 程序代码段，通常只读<br>data段 从stack一直到heap都是data段<br>bss段 Block Started by Symbol，定义而没有赋初值的全局变量和静态变量,放在这个区域，通常只是记录变量名和大小，相当于一个占位符。</p>
<p>data段里又包括栈、堆和文件映射区域</p>
<p>stack和heap是两头往中间着增长的，stack往地地址长，heap往高地址长。</p>
<p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p>
<p>brk是改变program break，来增加heap的大小</p>
<p>mmap是在进程的虚拟地址空间中（文件映射区域）找一块空闲的虚拟内存进行映射</p>
<p>注意，我们在上文中提到过，在访问地址之前，虚拟地址与物理地址的映射是未被建立的，因此这两种方式分配的都是虚拟内存，没有分配物理内存，会在第一次访问的时候通过缺页中断建立虚拟地址和物理地址的映射。</p>
<p>这个《深入理解计算机系统》的图不错，但是.rodata .init在网上图里都不是很常见</p>
<p><img src="/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1678868679096.png" alt="1678868679096"></p>
<p>1、只读段：该部分空间只能读，不可写；(包括：代码段、rodata 段(C常量字符串和#define定义的常量) )<br>2、数据段：保存全局变量、静态变量的空间；<br>3、堆 ：就是平时所说的动态内存， malloc/new 大部分都来源于此。其中堆顶的位置可通过函数 brk 和 sbrk 进行动态调整。<br>4、文件映射区域 ：如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。<br>5、栈：用于维护函数调用的上下文空间，一般为 8M ，可通过 ulimit –s 查看。<br>6、内核虚拟空间：用户代码不可见的内存区域，由内核管理(页表就存放在内核虚拟空间)。</p>
<h1 id="内存申请的多线程支持"><a href="#内存申请的多线程支持" class="headerlink" title="内存申请的多线程支持"></a>内存申请的多线程支持</h1><p>在之前的dlmalloc由于内存是临界资源，所以有上锁的问题导致效率较差，咱们ptmaloc2的解决办法是线程共享多个堆，即临界资源数量变多了。</p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-overview/#_5">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-overview/#_5</a></p>
<p><strong>虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong></p>
<p>这些被分配的内存被称为arena，主线程申请的内存为 main_arena，在子线程申请内存的时候会出现子arena</p>
<h1 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h1><p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。</p>
<p>malloc_chunk 的结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中INTERNAL_SIZE_T的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of</span></span><br><span class="line"><span class="comment">   chunk sizes.</span></span><br><span class="line"><span class="comment">   The default version is the same as size_t.</span></span><br><span class="line"><span class="comment">   While not strictly necessary, it is best to define this as an</span></span><br><span class="line"><span class="comment">   unsigned type, even if size_t is a signed type. This may avoid some</span></span><br><span class="line"><span class="comment">   artificial size limitations on some systems.</span></span><br><span class="line"><span class="comment">   On a 64-bit machine, you may be able to reduce malloc overhead by</span></span><br><span class="line"><span class="comment">   defining INTERNAL_SIZE_T to be a 32 bit `unsigned int&#x27; at the</span></span><br><span class="line"><span class="comment">   expense of not being able to handle more than 2^32 of malloced</span></span><br><span class="line"><span class="comment">   space. If this limitation is acceptable, you are encouraged to set</span></span><br><span class="line"><span class="comment">   this unless you are on a platform requiring 16byte alignments. In</span></span><br><span class="line"><span class="comment">   this case the alignment requirements turn out to negate any</span></span><br><span class="line"><span class="comment">   potential advantages of decreasing size_t word size.</span></span><br><span class="line"><span class="comment">   Implementors: Beware of the possible combinations of:</span></span><br><span class="line"><span class="comment">     - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits,</span></span><br><span class="line"><span class="comment">       and might be the same width as int or as long</span></span><br><span class="line"><span class="comment">     - size_t might have different width and signedness as INTERNAL_SIZE_T</span></span><br><span class="line"><span class="comment">     - int and long might be 32 or 64 bits, and might be the same width</span></span><br><span class="line"><span class="comment">   To deal with this, most comparisons and difference computations</span></span><br><span class="line"><span class="comment">   among INTERNAL_SIZE_Ts should cast them to unsigned long, being</span></span><br><span class="line"><span class="comment">   aware of the fact that casting an unsigned int to a wider long does</span></span><br><span class="line"><span class="comment">   not sign-extend. (This also makes checking for negative numbers</span></span><br><span class="line"><span class="comment">   awkward.) Some of these casts result in harmless compiler warnings</span></span><br><span class="line"><span class="comment">   on some systems.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding word size.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding bit mask value.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure>
<p>size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数</p>
<p>其他字段的含义如下</p>
<p><strong>prev_size</strong> , 如果该 chunk 的 <strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong> 是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储前一个 chunk 的数据。 *<em>这里的前一 chunk 指的是较低地址的 chunk *</em> 。（一个word都锱铢必较，这就是硬件层程序员的实力吗 跪）</p>
<p><strong>size</strong> ，该 chunk 的大小，单位是字节，需要注意的是大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示</p>
<ul>
<li>NON_MAIN_ARENA，记录当前 chunk <strong>是否不属于主线程</strong>，1 表示不属于，0 表示属于。</li>
<li>IS_MAPPED，记录当前 chunk <strong>是否是由 mmap 分配的</strong>。</li>
<li>PREV_INUSE，记录<strong>前一个 chunk 块是否被分配</strong>。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
<p>请注意，这个字段的最低3位用于存储其他信息，因此实际的chunk大小应该是size字段值与0xFFFFFFF8按位与的结果。也就因此最小的chunk至少也该是0b1000=8个字节。size域的大小为字长，即32位程序的size域大小为32位，64位程序的size域大小为64位。</p>
<p><strong>fd，bk</strong> 。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>
<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
<p>只有当chunk是free时，ptmalloc才会给chunk加上fd和bk指针，在chunk不free的时候，这两个字长的内存被user data使用。</p>
<p><strong>fd_nextsize， bk_nextsize</strong> ，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</p>
<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li>
</ul>
<p>大概是长这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             (size of chunk, but used <span class="keyword">for</span> application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|<span class="number">0</span>|<span class="number">1</span>|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>称Size of previous chunk, if unallocated和Size of chunk, in bytes为chunk header，后面的成为userdata</p>
<p>被释放的chunk以链表形式存储，在内存里的形式是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Forward pointer to next chunk in <span class="built_in">list</span>             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in <span class="built_in">list</span>            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             <span class="function">Unused <span class="title">space</span> <span class="params">(may be <span class="number">0</span> bytes <span class="keyword">long</span>)</span>                .</span></span><br><span class="line"><span class="function">        .                                                               .</span></span><br><span class="line"> next   .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`foot:&#x27; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|<span class="number">0</span>|<span class="number">0</span>|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p><strong>一般情况下</strong> ，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p>
<h2 id="做个实验"><a href="#做个实验" class="headerlink" title="做个实验"></a>做个实验</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  <span class="number">3</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">  <span class="number">4</span> </span><br><span class="line">  <span class="number">5</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="number">6</span>     <span class="keyword">char</span> *chunk1, *chunk2;</span><br><span class="line">  <span class="number">7</span>     chunk1=<span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">  <span class="number">8</span>     <span class="built_in">memset</span>(chunk1,<span class="number">0x41</span>,<span class="number">8</span>);</span><br><span class="line">  <span class="number">9</span>     chunk2=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line"> <span class="number">10</span>     <span class="built_in">memset</span>(chunk2,<span class="number">0x42</span>,<span class="number">24</span>);</span><br><span class="line"> <span class="number">11</span>     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="number">12</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在exit前下断点，查看堆</p>
<p><img src="/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1679542548660.png" alt="1679542548660"></p>
<p>可以看到chunk1的结构是</p>
<p>size域 0x00000000 00000021，根据size域的结构，chunk的大小应该是32字节</p>
<p>userdata域 0x41414141 41414141 00000000 00000000 00000000 00000000根据size对齐chunk应该是16对齐，因此这个chunk被多填充了</p>
<p>类似的，32位如下</p>
<p><img src="/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1679546079609.png" alt="1679546079609"></p>
<p>0x11=0b1 0001，大小为16字节</p>
<p>在最后的0x21e79应该是这个arena或者bin剩余的可用空间（但是我不是很确定）</p>
<p><img src="/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1679565334541.png" alt="1679565334541"></p>
<p>因为当我在多malloc几个字节，导致第二个chunk长了0x20的情况下，这个值会减少0x20</p>
<h1 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h1><p>我们曾经说过，用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p>
<p>在具体的实现中，ptmalloc 采用分箱式方法对空闲的 chunk 进行管理。首先，它会根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为 4 类：fast bins，small bins，large bins，unsorted bin。每类中仍然有更细的划分，fast bins以单链表连接来满足fast bins的效率需求，而其他的bins中的 chunk 会用双向链表链接起来。</p>
<p>对于small bins，large bins，unsorted bins 来说，ptmalloc 将它们维护在同一个数组bins array中。数组内存着mchunkptr指针，相当于一个头指针，指向一个由被free的chunk构成的链表</p>
<p><img src="/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1678876195800.png" alt="1678876195800"></p>
<p>上图可能有点误导，fast bin不在bins array中，bins array共维护128个bin的结构如下</p>
<ul>
<li>unsorted bin (bins array[0]),</li>
<li>small bins (bins array[1] to bins array[62]),</li>
<li>large bins (bins array[63] to bins array[126])</li>
<li>unsorted bin again (bins array[127])</li>
</ul>
<p>下面我们来细说一下不同的bins。</p>
<ul>
<li><strong>fast bins</strong> 。fast bins是bins的高速缓冲区，以单链表形式存在，大约有10个定长队列。当用户释放一块不大于max_fast（默认值64）的chunk（一般小内存）的时候，会默认会被放到fast bins上。当用户下次需要申请内存的时候首先会到fast bins上寻找是否有合适的chunk，然后才会到bins上空闲的chunk。ptmalloc会遍历fast bin，看是否有合适的chunk需要合并到bins上。为了更符合局部性原理，fast bins会采用LIFO的管理策略。</li>
<li><strong>unsorted bins</strong> 。只有一个链表，是bins的一个缓冲区。当用户释放的内存大于max_fast或者fast bins合并后的chunk都会进入unsorted bin上。当用户malloc的时候，先会到unsorted bin上查找是否有合适的bin，如果没有合适的bin，ptmalloc会将unsorted bin上的chunk放入合适的bins上，然后再到bins上查找合适的空闲chunk。unsorted bins采取FIFO的管理策略</li>
<li><strong>small bins和large bins</strong> 。small bins和large bins是真正用来放置chunk双向链表的。每个bin之间相差8个字节，并且通过上面的这个列表，可以快速定位到合适大小的空闲chunk。前64个为small bins，定长；后64个为large bins，非定长。</li>
<li><strong>Top chunk</strong> 。并不是所有的chunk都会被放到bins上。top chunk相当于分配区的顶部空闲内存，当bins上都不能满足内存分配要求的时候，就会来top chunk上分配。</li>
<li><strong>mmaped chunk。</strong> 当分配的内存非常大（大于分配阀值，默认128K）的时候，需要被mmap映射，则会放到mmaped chunk上，当释放mmaped chunk上的内存的时候会直接交还给操作系统。</li>
</ul>
<p>fast bins和unsorted bins链表中的chunk没有大小顺序，small bins和large bins中，每个bin里存放固定大小的chunk。</p>
<p>small bins的62个bins之间有固定的公差，如下图</p>
<p><img src="/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1678939847633.png" alt="1678939847633"></p>
<p>large bins的64个bins被分为了6组，不同组内的公差不一样大，如下图</p>
<p><img src="/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1678940138070.png" alt="1678940138070"></p>
<p>在分配内存时，ptmalloc2会以这样的优先级顺序来寻找chunk：</p>
<ol>
<li>fast bins (LIFO)</li>
<li>unsorted bins (FIFO)</li>
<li>small bins &amp; large bins</li>
</ol>
<h1 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h1><p>之前我们介绍过，ptmalloc为了实现多线程，使用了arena，无论是主线程还是新创建的线程，在第一次申请内存时，都会有独立的 arena。但是arena也有数量限制，在32位系统中，arena的数量为处理器核心数的2倍，64位系统中则为核心数的8倍。</p>
<p>一个arena里的结构大概是这样了</p>
<p><img src="/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1678936741807.png" alt="arena的结"></p>
<p>还有一个 Top Chunk</p>
<p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</p>
<p>至此，我们已经可以宏观的看待ptmalloc2堆内存分配了：</p>
<p>线程与arena对应，每个arena中含有多个bins，每个bin里存放着一个个的chunk，chunk是malloc的单位</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/">https://ctf-wiki.org/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gfgdsg/article/details/42709943">https://blog.csdn.net/gfgdsg/article/details/42709943</a></p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1467962">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1467962</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">π1L4r</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.pillar.fun/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">https://blog.pillar.fun/2022/03/15/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.pillar.fun" target="_blank">π1L4r</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a><a class="post-meta__tags" href="/tags/basic/">basic</a></div><div class="post_share"><div class="social-share" data-image="/img/cover3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-%E4%BD%A0%E4%BC%A0%E4%BD%A0m%E5%91%A2/"><img class="prev-cover" src="/img/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BUU刷题日记-你传你m呢</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/20/hgame2022-wp/"><img class="next-cover" src="/img/cover3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">hgame2022_wp</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/07/19/PlayWithAndroidKernel/" title="PlayWithAndroidKernel"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-19</div><div class="title">PlayWithAndroidKernel</div></div></a></div><div><a href="/2020/07/22/安卓内核pwn之缓冲区溢出/" title="安卓内核pwn之缓冲区溢出"><img class="cover" src="/img/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-22</div><div class="title">安卓内核pwn之缓冲区溢出</div></div></a></div><div><a href="/2021/01/27/BUU刷题日记-bjdctf-2020-babystack/" title="BUU刷题日记_bjdctf_2020_babystack"><img class="cover" src="/img/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-27</div><div class="title">BUU刷题日记_bjdctf_2020_babystack</div></div></a></div><div><a href="/2021/01/30/BUU刷题日记-get-started-3dsctf-2016/" title="BUU刷题日记_get_started_3dsctf_2016"><img class="cover" src="/img/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-30</div><div class="title">BUU刷题日记_get_started_3dsctf_2016</div></div></a></div><div><a href="/2020/10/04/BUU刷题日记-PWN5/" title="BUU刷题日记_PWN5"><img class="cover" src="/img/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-04</div><div class="title">BUU刷题日记_PWN5</div></div></a></div><div><a href="/2022/04/22/堆溢出基础/" title="堆溢出基础"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-22</div><div class="title">堆溢出基础</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/author.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">π1L4r</div><div class="author-info__description">changed my nickname= =.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/such-stupid6"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/such-stupid6" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:alexi_bi@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">新年快乐！继续前行！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E8%AF%AD"><span class="toc-number">1.</span> <span class="toc-text">导语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">堆的简单介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">程序的内存结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81"><span class="toc-number">4.</span> <span class="toc-text">内存申请的多线程支持</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chunk"><span class="toc-number">5.</span> <span class="toc-text">chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9A%E4%B8%AA%E5%AE%9E%E9%AA%8C"><span class="toc-number">5.1.</span> <span class="toc-text">做个实验</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bin"><span class="toc-number">6.</span> <span class="toc-text">bin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arena"><span class="toc-number">7.</span> <span class="toc-text">arena</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/23/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" title="格式化字符串漏洞"><img src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="格式化字符串漏洞"/></a><div class="content"><a class="title" href="/2023/02/23/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" title="格式化字符串漏洞">格式化字符串漏洞</a><time datetime="2023-02-23T09:46:47.000Z" title="发表于 2023-02-23 17:46:47">2023-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/19/mqtt-pwn%E5%AE%89%E8%A3%85/" title="mqtt-pwn安装"><img src="/img/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mqtt-pwn安装"/></a><div class="content"><a class="title" href="/2023/01/19/mqtt-pwn%E5%AE%89%E8%A3%85/" title="mqtt-pwn安装">mqtt-pwn安装</a><time datetime="2023-01-19T03:55:43.000Z" title="发表于 2023-01-19 11:55:43">2023-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/06/HGAME2023/" title="HGAME2023"><img src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HGAME2023"/></a><div class="content"><a class="title" href="/2023/01/06/HGAME2023/" title="HGAME2023">HGAME2023</a><time datetime="2023-01-06T05:06:43.000Z" title="发表于 2023-01-06 13:06:43">2023-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/04/%E9%83%A8%E7%BD%B2Hfish%E8%9C%9C%E7%BD%90/" title="部署Hfish蜜罐"><img src="/img/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="部署Hfish蜜罐"/></a><div class="content"><a class="title" href="/2023/01/04/%E9%83%A8%E7%BD%B2Hfish%E8%9C%9C%E7%BD%90/" title="部署Hfish蜜罐">部署Hfish蜜罐</a><time datetime="2023-01-04T03:07:42.000Z" title="发表于 2023-01-04 11:07:42">2023-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/03/rhcsa-rhce%E9%80%9A%E5%85%B3%E6%94%BB%E7%95%A5/" title="rhcsa+rhce通关攻略"><img src="/img/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="rhcsa+rhce通关攻略"/></a><div class="content"><a class="title" href="/2023/01/03/rhcsa-rhce%E9%80%9A%E5%85%B3%E6%94%BB%E7%95%A5/" title="rhcsa+rhce通关攻略">rhcsa+rhce通关攻略</a><time datetime="2023-01-03T04:39:36.000Z" title="发表于 2023-01-03 12:39:36">2023-01-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/cover3.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By π1L4r</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎留言加友链鸭</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    let initData = {
      el: '#waline-wrap',
      serverURL: 'https://wakube-6ydq4vd03-such-stupid6.vercel.app/',
      avatar: 'monsterid',
      path: location.pathname,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba,https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili',
      emojiMaps: "",
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const waline = new Waline(initData)
  }

  if (typeof Waline === 'function') initWaline() 
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script> <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.6.0/build/highlight.min.js"></script> <script>hljs.initHighlightingOnLoad();</script> <script src="/js/diy.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="自强,弘毅,求是,拓新" data-fontsize="15px" data-random="false" async="async"></script><script>((window.gitter = {}).chat = {}).options = {
  disableDefaultChat: true,
};
document.addEventListener('gitter-sidecar-ready', (e) => {
  const GitterChat = e.detail.Chat
  let chat

  function initGitter () {
    chat = new GitterChat({
      room: 'such-stupid6/to_chat_with',
      activationElement: '#chat_btn'
    });
  }

  initGitter()

  if (false) {
    document.addEventListener('pjax:complete', () => {
      chat.destroy()
      initGitter()
    })
  }

})</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async="async" defer="defer"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"log":false});</script></body></html>